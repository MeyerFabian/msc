\documentclass[m,times]{cgMA}

\usepackage{listings}
\usepackage{xurl}
\urlstyle{sf}
\usepackage{hyperref}
\usepackage{amsmath}
\usepackage{bm}
\usepackage{textcomp}
\usepackage{caption}
\usepackage{color}
\usepackage{subfigure}
\usepackage{wrapfig}
\usepackage[english,ngerman]{babel}
\usepackage[backend=biber,style=alphabetic]{biblatex}
\usepackage{algorithm}% http://ctan.org/pkg/algorithms
\usepackage{algpseudocode}% http://ctan.org/pkg/algorithmicx
\usepackage{mathtools}
\usepackage{subdepth}
\addbibresource{mscthesis.bib}

\lstdefinelanguage{GLSL}
{
  sensitive=true,
  morekeywords=[1]{
    attribute, const, uniform, varying,
    layout, centroid, flat, smooth,
    noperspective, break, continue, do,
    for, while, switch, case, default, if,
    else, in, out, inout, float, int, void,
    bool, true, false, invariant, discard,
    return, mat2, mat3, mat4, mat2x2, mat2x3,
    mat2x4, mat3x2, mat3x3, mat3x4, mat4x2,
    mat4x3, mat4x4, vec2, vec3, vec4, ivec2,
    ivec3, ivec4, bvec2, bvec3, bvec4, uint,
    uvec2, uvec3, uvec4, lowp, mediump, highp,
    precision, sampler1D, sampler2D, sampler3D,
    samplerCube, sampler1DShadow,
    sampler2DShadow, samplerCubeShadow,
    sampler1DArray, sampler2DArray,
    sampler1DArrayShadow, sampler2DArrayShadow,
    isampler1D, isampler2D, isampler3D,
    isamplerCube, isampler1DArray,
    isampler2DArray, usampler1D, usampler2D,
    usampler3D, usamplerCube, usampler1DArray,
    usampler2DArray, sampler2DRect,
    sampler2DRectShadow, isampler2DRect,
    usampler2DRect, samplerBuffer,
    isamplerBuffer, usamplerBuffer, sampler2DMS,
    isampler2DMS, usampler2DMS,
    sampler2DMSArray, isampler2DMSArray,
  usampler2DMSArray, struct},
  morekeywords=[2]{
    radians,degrees,sin,cos,tan,asin,acos,atan,
    atan,sinh,cosh,tanh,asinh,acosh,atanh,pow,
    exp,log,exp2,log2,sqrt,inversesqrt,abs,sign,
    floor,trunc,round,roundEven,ceil,fract,mod,modf,
    min,max,clamp,mix,step,smoothstep,isnan,isinf,
    floatBitsToInt,floatBitsToUint,intBitsToFloat,
    uintBitsToFloat,length,distance,dot,cross,
    normalize,faceforward,reflect,refract,
    matrixCompMult,outerProduct,transpose,
    determinant,inverse,lessThan,lessThanEqual,
    greaterThan,greaterThanEqual,equal,notEqual,
    any,all,not,textureSize,texture,textureProj,
    textureLod,textureOffset,texelFetch,
    texelFetchOffset,textureProjOffset,
    textureLodOffset,textureProjLod,
    textureProjLodOffset,textureGrad,
    textureGradOffset,textureProjGrad,
    textureProjGradOffset,texture1D,texture1DProj,
    texture1DProjLod,texture2D,texture2DProj,
    texture2DLod,texture2DProjLod,texture3D,
    texture3DProj,texture3DLod,texture3DProjLod,
    textureCube,textureCubeLod,shadow1D,shadow2D,
    shadow1DProj,shadow2DProj,shadow1DLod,
    shadow2DLod,shadow1DProjLod,shadow2DProjLod,
    dFdx,dFdy,fwidth,noise1,noise2,noise3,noise4,
  EmitVertex,EndPrimitive},
  morekeywords=[3]{
    gl_VertexID,gl_InstanceID,gl_Position,
    gl_PointSize,gl_ClipDistance,gl_PerVertex,
    gl_Layer,gl_ClipVertex,gl_FragCoord,
    gl_FrontFacing,gl_ClipDistance,gl_FragColor,
    gl_FragData,gl_MaxDrawBuffers,gl_FragDepth,
    gl_PointCoord,gl_PrimitiveID,
    gl_MaxVertexAttribs,gl_MaxVertexUniformComponents,
    gl_MaxVaryingFloats,gl_MaxVaryingComponents,
    gl_MaxVertexOutputComponents,
    gl_MaxGeometryInputComponents,
    gl_MaxGeometryOutputComponents,
    gl_MaxFragmentInputComponents,
    gl_MaxVertexTextureImageUnits,
    gl_MaxCombinedTextureImageUnits,
    gl_MaxTextureImageUnits,
    gl_MaxFragmentUniformComponents,
    gl_MaxDrawBuffers,gl_MaxClipDistances,
    gl_MaxGeometryTextureImageUnits,
    gl_MaxGeometryOutputVertices,
    gl_MaxGeometryOutputVertices,
    gl_MaxGeometryTotalOutputComponents,
    gl_MaxGeometryUniformComponents,
  gl_MaxGeometryVaryingComponents,gl_DepthRange},
  morecomment=[l]{//},
  morecomment=[s]{/*}{*/},
  morecomment=[l][keywordstyle4]{\#},
}
\lstdefinestyle{GL}{
  tabsize=2,
  rulecolor=,
  basicstyle=\scriptsize,
  upquote=true,
  aboveskip={0.5\baselineskip},
  belowskip={1.5\baselineskip},
  columns=fixed,
  showstringspaces=false,
  extendedchars=true,
  breaklines=true,
  prebreak = \raisebox{0ex}[0ex][0ex]{\ensuremath{\hookleftarrow}},
  frame=single,
  showtabs=false,
  showspaces=false,
  showstringspaces=false,
  identifierstyle=\ttfamily,
  keywordstyle=\color[rgb]{1.0,0,0},
  keywordstyle=[1]\color[rgb]{0,0,0.75},
  keywordstyle=[2]\color[rgb]{0.5,0.0,0.0},
  keywordstyle=[3]\color[rgb]{0.127,0.427,0.514},
  keywordstyle=[4]\color[rgb]{0.4,0.4,0.4},
  commentstyle=\color[rgb]{0.133,0.545,0.133},
  stringstyle=\color[rgb]{0.639,0.082,0.082},
  numbers=left,
}
\renewcommand{\lstlistingname}{Source code}

\renewcommand{\lstlistlistingname}{List of source codes}



\begin{document}

\author{Fabian Meyer}
\title{GPU-Beschleunigung der Material Point Method}
\zweitgutachter{Bastian Krayer, M.Sc.}
\zweitgutachterInfo{(Institut f{\"u}r Computervisualistik, AG Computergraphik)}
% Umschalten der Sprache (fuer englische Rubrikbezeichnungen etc.)


\pagenumbering{roman}
\maketitle

\clearpage
\selectlanguage{english}
\subsubsection*{Abstract}

\noindent Physic

%\vfill~
%ggf. noch'n \vfill~

\clearpage
\tableofcontents

%\setcounter{page}{3}
\clearpage         % oder \cleardoublepage bei zweiseitigem Druck
% \listoffigures   % fuer ein eventuelles Abbildungsverzeichnis
% \clearpage
\pagenumbering{arabic}


\section{Introduction} \label{intro}
bib-test \cite{MPM:SNOW}
$$ -  \int_{\pi/2}^{\pi} \frac{1}{\sqrt{u}} \frac{\lvert \cos{x} \rvert}{\cos{x}} du $$
\subsection{Motivation}
\section{Related Work}
\cite{PIC:GPU} -> \cite{NVIDIA:NNSEARCH}
benefits over radix sort /thrust sort-by-key -> counting sort
\cite{NVIDIA:SHUFFLE}

\cite{MPM:GPU}
%look again for MPM/PIC gpu impl
%SPH, FEM methods
\section{Notation}
Einstein-Notation
\section{Basics}
\subsection{Continuum Mechanics}
\cite{MPM:COURSE}
\subsection{Singular Value Decomposition}
\cite{SVD:3x3}
\subsection{Constitutive Models}
\cite{MPM:DRUCKER} %Sand Plasticity
\cite{MPM:MULTI} %Sand+Water
\cite{MPM:INVERT} %Neo-Hookean
\cite{MPM:OLROYDB} %Viscoelastic Foam,Sponge
\cite{MPM:SHELLS} %Thin Shells
\cite{MPM:PHASE_CHANGE} %Heat-Model
\cite{MPM:OPTIMI_INTEGR} %Opimization Methods, BDF-Semi-Impl-Midpoint rule

The first aim will be to find the strain energy density $\psi(\mathbf{\epsilon})$ of the strain $\bm{\epsilon}$.
For an (hyper-)elastic material the Cauchy stress may be defined in terms of $\psi$ as:
The most general linear stress-strain relationship is given by Hooke's Law in three dimensions
\begin{equation}\label{eq:hook}
  \sigma_{ij} = C_{ijkl} \epsilon_{kl},
\end{equation}
where $\mathbf{\sigma}$ and $\bm{\epsilon}$ are second-order tensors with (3x3) = 9 elements. $C_{ijkl}$ is a fourth-order tensor with (3x3)x(3x3) = 81 elements.
Assuming following symmetries reduces the tensors to 6 and 21 unique elements respectively:
\begin{enumerate}
  \item Conservation of angular momentum: $\sigma_{ij} = \sigma_{ji} \Rightarrow C_{ijkl} = C_{jikl} $
  \item No-net-rotation: $\epsilon_{kl} = \epsilon_{lk} \Rightarrow C_{ijkl} = C_{ijlk}$
  \item \label{it:mixed_partials}Equivalence of second-order mixed partials of $\psi$:
    \begin{equation}
      C _ { i j k l } = \frac { \partial ^ { 2 } { \psi } } { \partial \epsilon _ { k l } \partial \epsilon _ { i j } } = \frac { \partial ^ { 2 } { \psi } } { \partial \epsilon _ { i j } \partial \epsilon _ { k l } } = C _ { k l i j },
    \end{equation}
\end{enumerate}
where item \ref{it:mixed_partials} holds for the strain energy density functional of an (hyper-)elastic material. The stress may then also be calculated by
\begin{equation}\label{eq:partial_energy}
  \sigma _ { i j } = \sigma _ { i j } ( \mathbf{\epsilon} ) = \frac { \partial { \psi } } { \partial \epsilon _ { i j } },
\end{equation}
if such a $\psi$ is given. An isotropic (direction-independent) linear elastic material further only has three unique elements $C _ {i j k l}$. Using Voigt-Notation, which collapses indices $i=j$ and $k=l$, equation \ref{eq:hook} can be rewritten as:
\begin{equation} \label{eq:voigt}
  \left[ \begin{array} {c}
      {\sigma_{11}}\\
      {\sigma_{22}}\\
      {\sigma_{33}}\\
      {\sigma_{23}}\\
      {\sigma_{13}}\\
      {\sigma_{12}}\\
  \end{array} \right]
  = \left[ \begin{array} { c c c c c c }
      { C _ { 11 }   } & { C _ { 12 } } & { C _ { 12 } } & 0                & 0                & 0 \\
      {}               & { C _ { 11 } } & { C _ { 12 } } & 0                & 0                & 0 \\
      {}               & {}             & { C _ { 11 } } & 0                & 0                & 0 \\
      {}               & {}             & {}             & { C _ { 22 } }   & 0                & 0 \\
      {}               & {}             & {}             & {}               & { C _ { 22 } }   & 0 \\
      {sym}            & {}             & {}             & {}               & {}               & { C _ { 22 } } \\
  \end{array} \right]
  \left[ \begin{array} {c}
      {\epsilon_{11}}\\
      {\epsilon_{22}}\\
      {\epsilon_{33}}\\
      {\gamma_{23}}\\
      {\gamma_{13}}\\
      {\gamma_{12}}\\
  \end{array} \right]
\end{equation}
Experimental results of Hooke's law commonly give
\begin{equation}
  \boldsymbol{\epsilon} =
  \epsilon _ { i j } = \frac { 1 } { E } \left[ ( 1 + \nu ) \sigma _ { i j } - \nu \sigma _ { k k } \delta _ { i j } \right]
  = \mathbf{C}^{-1} \bm{\sigma}
\end{equation}
using engineering constants Young's modulus $E$ and Poisson ratio $\nu$. Inverting $\mathbf{C}^{-1}$ and switching to Lamé parameters $\lambda$ and $\mu$ results in the equation:
\begin{equation} \label{eq:stress_strain}
  \sigma_{ij} = 2\mu \epsilon_{ij} + \lambda \text{tr}(\boldsymbol{\epsilon}) \delta_{ij}.
\end{equation}
Comparing with equation \ref{eq:voigt} leads to coefficients $\gamma_{ij} = 2\epsilon_{ij} \text{ for } (i \neq j)$, $C_{11} = \lambda +2 \mu$, $C_{12} = \lambda$ and $C_{22} = \mu$. $\gamma$ is also referred to as the engineering strain. Due to the relationship in \ref{eq:partial_energy} the model for linear elasticity in terms of the strain energy density function $\psi_{LE}$ after integration of \ref{eq:stress_strain} concludes to:
\begin{equation}\label{eq:linear_elas}
  \psi_{LE} = \mu \Vert \boldsymbol{\epsilon} \Vert^2_F + \frac{\lambda}{2} \text{tr}^2(\boldsymbol{\epsilon}).
\end{equation}
\cite{MIT:LINEAR_ELASTICITY}
\subsubsection{Fixed Corotated Hyperelasticity}
The simplest tensor assumed by infinitesimal strain theory is the small strain tensor: \begin{equation}
  \boldsymbol{\epsilon} = \frac { 1 } { 2 } \left( \mathbf { F }_E + \mathbf { F }_E ^ { T } \right) - \mathbf { I }
\end{equation}
The energy produced by equation \ref{eq:linear_elas} using the small strain tensor is not rotationally invariant, w.r.t. to $\mathbf{F}_E$: $\psi(\mathbf{R}_{0} \mathbf{F}_E) \neq \psi(\mathbf{F}_E)$. The deformation caused by stress however does not affect rigid body motions. Given the polar decomposition $\mathbf{F}_E = \mathbf{R}_E\mathbf{S}_E$, an alternate strain measure may be defined as:
\begin{equation}
  \hat { \boldsymbol { \epsilon } } ( \mathbf { F }_E ) = \boldsymbol { \epsilon } \left( \mathbf { R }_E ^ { T } \mathbf { F }_E \right) = \frac { 1 } { 2 } \left( \mathbf { R }_E ^ { T } \mathbf { F }_E + \left( \mathbf { R }_E ^ { T } \mathbf { F }_E \right) ^ { T } \right) - \mathbf { I } = \mathbf { S }_E - \mathbf { I }
\end{equation}
Substituting $\hat{\boldsymbol{\epsilon}}$ into equation \ref{eq:linear_elas} leads to the energy definition of corotational hyperelasticity:
\begin{equation}\label{eq:corot_S}
  \Psi = \mu \| \mathbf{ S }_E - \mathbf { I } \| _ { F } ^ { 2 } + \frac { \lambda } { 2 } \operatorname { tr } ^ { 2 } ( \mathbf { S }_E - \mathbf { I } )
\end{equation}
Using rotation-invariance of the Frobenius norm:
\begin{equation}
  \Psi = \mu \| \mathbf {F}_E  - \mathbf {R}_E \| _ { F } ^ { 2 } + \frac { \lambda } { 2 } \operatorname { tr } ^ { 2 } \left( \mathbf { R }_E ^ { T } \mathbf { F }_E - \mathbf { I } \right)
\end{equation}
Even more insight yields the relationship to their singular values $\sigma _ i$, also called the principal stretches:
$$\operatorname {tr}\left(\mathbf{S}\right) = \sum _ { i = 1 } \sigma _ { i } = \operatorname{tr}\left(\mathbf{\Sigma}_E\right)$$
$$\| \mathbf{S}_E \| _ { F }^2 = \sum _ { i = 1 } \sigma _ { i } ^ { 2 } = \| \mathbf{\Sigma}_E\|_{F}^2$$
$$\Rightarrow \| \mathbf{S}_E\mathbf{-I} \| _ { F }^2 = \|\mathbf{S}_E \| _ { F }^2 - 2 \operatorname{tr}(\mathbf{S}_E)  + \|\mathbf{I}\|_{F}^2 = \| \boldsymbol { \Sigma }_E - \mathbf { I } \| _ { F } ^ { 2 }$$
\begin{equation} \label{eq:corot_sing}
  \Psi(\boldsymbol{\Sigma}_E) = \mu \| \boldsymbol { \Sigma }_E - \mathbf { I } \| _ { F } ^ { 2 } + \frac { \lambda } { 2 } \operatorname { tr } ^ { 2 } ( \boldsymbol { \Sigma }_E - \mathbf { I } )
\end{equation}
Equation \ref{eq:corot_sing} uses the diagonal matrix $\mathbf{\Sigma}_E$ containing the principal stretches typically acquired by the singular value decomposition $\mathbf{F}_E \mathbf{= U \Sigma}_E\mathbf{ V ^T }.$ Since the energy density in \ref{eq:corot_sing} is a function of only three (singular) values, which describe stretch/compression of the material, isotropy of the material is underlined.
\cite{ADAMS:ELASTICITY}
Numerical Stepping algorithms
-> Newton Raphson scheme
-> Problem: Bad Primary contour
Benefit: Easier description in terms of Invariants
\cite{MPM:INVERT}

\subsection{Material Point Method}
\subsubsection{Conservation Equations}
\cite{MPM:APIC}
\subsubsection{CFL Condition}
\subsection{GPU memory}
\subsubsection{Optimization opportunities}
\cite{NVIDIA:BEST:PRACTICE}
\cite{AMD:GPU_OPEN}
\begin{itemize}
  \item Minimize CPU-GPU transfers
  \item Coalesced memory access
  \item Bank conflicts
\end{itemize}
\subsubsection{SoA vs. AoS}
\section{Implementation}
\newcommand{\var}[1]{{\ttfamily#1}}% variable
\begin{algorithm}[t]
  \caption{Euclid’s algorithm}\label{euclid}
  \begin{algorithmic}[1]
    \Procedure{Euclid}{$a,b$}\Comment{The g.c.d. of a and b}
    \State $r\gets a\mathbfod b$ and \var{foobar}\label{foobar}
    \While{$r\not=0$}\Comment{We have the answer if r is 0}
    \State $a\gets b$
    \State $b\gets r$
    \State $r\gets a\mathbfod b$
    \EndWhile\label{euclidendwhile}
    \State \textbf{return} $b$\Comment{The gcd is b}
    \EndProcedure
  \end{algorithmic}
\end{algorithm}
\subsection{Framework}
decorator pattern
\subsection{Parallel Reduction}
\cite{NVIDIA:PARALLEL_REDUCTION}
\subsection{Binning}
\cite{NVIDIA:BINNING}
\subsection{Scanning}
\cite{NVIDIA:SCAN}
\cite{NVIDIA:SCAN_MODERN}
\subsection{Affine particle-in-cell}
\cite{MPM:APIC}
\subsection{Iterative solvers for linear systems}
%GMRES, Conjugate Gradients
\subsection{Verifying Simulation}
\begin{itemize}
  \item Conservation equations
  \item Singular Value Decomposition
  \item Parallel Reduction
\end{itemize}
\section{Evaluation}
\cite{NVIDIA:PEAK_PERFORMANCE}
\cite{KHRONOS:TIMER_QUERY}
\section{Conclusion}
\subsection{Review}
\subsection{Future Work}
Particle Activation: \cite{MPM:GPU}

Sparse: \cite{OPENVDB} \cite{NVIDIA:GVDB_VOXELS}

\listoffigures
\clearpage
\listoftables
\lstlistoflistings
\clearpage
\selectlanguage{english}
\printbibliography
\end{document}
